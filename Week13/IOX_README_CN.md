# iox

[English](https://github.com/EddieIvan01/iox) | 中文

端口转发 & 内网代理工具，功能类似于`lcx`/`ew`，但是比它们更好

# 为什么写iox?

`lcx`和`ew`是很优秀的工具，但还可以提高

在最初使用它们的很长一段时间里，我都记不住那些复杂的命令行参数，诸如`tran, slave, rcsocks, sssocks`。工具的工作模式很清晰，明明可以用简单的参数表示，为什么他们要设计成这样（特别是`ew`的`-l -d -e -f -g -h`）

除此之外，我认为网络编程的逻辑可以优化

举个栗子，当运行`lcx -listen 8888 9999`命令时，客户端必须先连`:8888`，再连`:9999`，实际上这两个端口是平等的，在`iox`里则没有这个限制。当运行`lcx -slave 1.1.1.1 8888 1.1.1.1 9999`命令时，`lcx`会串行的连接两个主机，但是并发连接两个主机会更高效，毕竟是纯I/O操作，`iox`就是这样做的

更进一步，`iox`提供了流量加密功能 (当目标有IDS时会很有用)。实际上，你可以直接将`iox`当做一个简易的ShadowSocks使用

`iox`还提供了UDP流量转发的功能

当然，因为`iox`是用Go写的，所以静态连接的程序有一点大，原程序有2.2MB（UPX压缩后800KB）

# 特性

+ 流量加密（可选）
+ 友好的命令行参数
+ 逻辑优化
+ UDP流量转发
+ 反向代理模式中使用TCP多路复用

# 用法

所有的参数都是统一的。`-l/--local`意为监听本地端口；`-r/--remote`意为连接远端主机

**注意: v0.4版本之后, `-l/--local`参数可以指定监听哪个IP。如果只指定了端口，则默认是`0.0.0.0:PORT`**

```
-l 127.0.0.1:9999      -l *127.0.0.1:9999      # 127.0.0.1:9999
-l 9999                -l *9999                # 0.0.0.0:9999

`-l :9999`也是可以的，但并不推荐。因为`-l *:9999`(监听0.0.0.0:9999，开启加密)会有歧义
```

## 工作模式

### fwd

监听 `0.0.0.0:8888` 和`0.0.0.0:9999`，将两个连接间的流量转发

```
./iox fwd -l 8888 -l 9999
```

监听`0.0.0.0:8888`，把流量转发到`1.1.1.1:9999`

```
./iox fwd -l 8888 -r 1.1.1.1:9999
```

连接`1.1.1.1:8888`和`1.1.1.1:9999`, 在两个连接间转发

```
./iox fwd -r 1.1.1.1:8888 -r 1.1.1.1:9999
```

### proxy

在本地 `0.0.0.0:1080`启动Socks5服务

```
./iox proxy -l 1080
```

在被控机开启Socks5服务，将服务转发到公网VPS

在VPS上转发`0.0.0.0:9999`到`0.0.0.0:1080`

你必须将两条命令成对使用，因为它内部包含了一个简单的协议来控制回连

```
./iox proxy -r 1.1.1.1:9999
./iox proxy -l 9999 -l 1080       // 注意，这两个端口是有顺序的
```

接着连接内网主机

```
# proxychains.conf
# socks5://1.1.1.1:1080

$ proxychains rdesktop 192.168.0.100:3389
```

***

## 启用加密

举个栗子，我们把内网3389端口转发到VPS

```
// 被控主机
./iox fwd -r 192.168.0.100:3389 -r *1.1.1.1:8888 -k 656565


// 我们的VPS
./iox fwd -l *8888 -l 33890 -k 656565
```

很好理解：被控主机和VPS:8888之间的流量会被加密，预共享的密钥是'AAA'，`iox`会用这个密钥生成种子密钥和nonce（**正常来讲，不应该复用nonce。但是考虑到iox的加密功能仅仅为了绕过IDS等设备，为了不额外分配空间，TCP流加密会复用nonce**），并用Xchacha20流加密 (在v0.3版本中用Xchacha20替换掉了AES-CTR)

所以，`*`应该成对使用

```
./iox fwd -l 1000 -r *127.0.0.1:1001 -k 000102
./iox fwd -l *1001 -r *127.0.0.1:1002 -k 000102
./iox fwd -l *1002 -r *127.0.0.1:1003 -k 000102
./iox proxy -l *1003 -k 000102


$ curl google.com -x socks5://127.0.0.1:1000
```

你也可以把`iox`当做一个简单的ShadowSocks来用：

```
// ssserver
./iox proxy -l *9999 -k 000102


// sslocal
./iox fwd -l 1080 -r *VPS:9999 -k 000102
```

## UDP转发

只需要添加命令行参数：`-u`

```
./iox fwd -l 53 -r *127.0.0.1:8888 -k 000102 -u
./iox fwd -l *8888 -l *9999 -k 000102 -u
./iox fwd -r *127.0.0.1:9999 -r 8.8.8.8:53 -k 000102 -u
```

**注意：当你做多级连接的转发时，`Remote2Remote-UDP-mode`必须最后一个被启动，也就是上面示例中的第三条**

UDP转发可能会有一些不合你预期的行为。实际上，目前在GitHub上只有将本地监听的UDP流量转发到远程主机的例子，所以我只能以我的理解来实现

你可以在源码里找到答案，如果你有什么想法，欢迎提PR / issue

# 许可

The MIT license

